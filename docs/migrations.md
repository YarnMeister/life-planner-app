# Database Migrations

Approach: Forward-only, Git-tracked SQL migrations generated by Drizzle. Apply the same scripts to TEST, then PROD.

## Environments and Secrets

Local development:
- Create `.env.local` with `DATABASE_URL` pointing to TEST database
- Never commit `.env.local` to Git
- Never connect to PROD from a laptop

GitHub Actions (TEST):
- Set `DATABASE_URL` in repository Settings > Secrets and variables > Actions > Repository secrets
- Points to TEST database
- Used by CI workflow on push/PR

Vercel (PROD):
- Set `PROD_DATABASE_URL` in project Settings > Environment Variables
- Scope: Production only
- `drizzle.config.ts` checks for this variable first

## File Layout

```
/drizzle/
  migrations/          SQL files checked into Git
  schema.ts            Drizzle schema source
drizzle.config.ts      Config for drizzle-kit
scripts/
  lint-migrations.cjs  Blocks destructive SQL
  test-rls.mjs         Verifies RLS policies
  audit-rls.mjs        Enforces RLS coverage
  audit-raw-sql.mjs    Blocks DDL outside migrations
```

## Commands

```json
{
  "scripts": {
    "db:generate": "drizzle-kit generate",
    "db:migrate": "drizzle-kit migrate",
    "db:status": "drizzle-kit check",
    "db:lint:migrations": "node scripts/lint-migrations.cjs",
    "db:test-rls": "node scripts/test-rls.mjs",
    "db:audit-rls": "node scripts/audit-rls.mjs",
    "db:audit-raw-sql": "node scripts/audit-raw-sql.mjs"
  }
}
```

## Authoring Migrations

1. Edit `drizzle/schema.ts`
2. Run `npm run db:generate`
3. Review generated SQL in `drizzle/migrations/`
4. Test locally: `npm run db:migrate`
5. Commit schema + migration SQL + metadata

For manual SQL migrations (like RLS policies):
- Create SQL file following naming convention: `NNNN_description.sql`
- Update `drizzle/migrations/meta/_journal.json` to register the migration
- Create minimal snapshot file in `drizzle/migrations/meta/NNNN_snapshot.json`

## Deployment Flow

1. Push to feature branch
2. Open PR to main
3. GitHub Actions runs on PR:
   - Lint migrations
   - Apply to TEST database
   - Run RLS tests
   - Run RLS coverage audit
   - Run raw SQL audit
4. If any check fails, PR shows red X and Vercel auto-deploy is blocked
5. Merge to main after PR checks pass
6. Vercel auto-deploys:
   - Lint migrations
   - Apply to PROD database
   - Build application
   - Deploy

Critical: Failed GitHub Actions checks silently block Vercel auto-deploy. If Vercel doesn't deploy after merge, check the Actions tab for red X. This often looks like webhook/config issues but is actually failed CI tests.

## GitHub Actions Workflow

Located at `.github/workflows/test-migrations.yml`:

```yaml
on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  test-migrations:
    runs-on: ubuntu-latest
    env:
      DATABASE_URL: ${{ secrets.DATABASE_URL }}
    steps:
      - Checkout code
      - Install dependencies
      - Ensure DATABASE_URL secret exists
      - Lint migrations
      - Apply migrations to TEST
      - Check migration status
      - Run RLS harness
      - Audit RLS coverage
      - Audit raw SQL
```

All steps must pass for Vercel to deploy. Check workflow logs if deployment doesn't trigger.

## Destructive Operations

Avoid `DROP TABLE`, `DROP COLUMN`, `TRUNCATE`, `DELETE FROM`.

If required, add comment tag to migration:

```sql
-- allow-destructive
DROP TABLE old_table;
```

Without this tag, linter fails and blocks deployment.

## RLS Pattern

Enable RLS with SQL migrations:

```sql
ALTER TABLE table_name ENABLE ROW LEVEL SECURITY;
ALTER TABLE table_name FORCE ROW LEVEL SECURITY;

CREATE POLICY table_role_operation
  ON table_name
  FOR SELECT
  USING (condition);
```

Naming convention: `{table}_{role}_{operation}`

Use session GUCs for identity:
- `current_setting('app.user_id', true)::uuid` for user-scoped
- `current_setting('app.site_id', true)::uuid` for site-scoped

RLS Audits:
- `npm run db:test-rls` - Verifies policy existence and basic behavior
- `npm run db:audit-rls` - Fails if any non-lookup table lacks CRUD policies

Lookup tables (ending in `_lu`) are exempt from RLS requirements.

## Data Migrations

Keep data changes small (hundreds of rows, not thousands):

```sql
INSERT INTO table (col1, col2)
VALUES ('val1', 'val2')
ON CONFLICT (col1) DO NOTHING;
```

Use explicit keys. Avoid fuzzy matching. Test in TEST first.

## Rollback Philosophy

Forward-only. To undo a change, ship a new migration that reverts it.

No rollback scripts. If emergency restoration needed, coordinate with DB provider.

## ENUM vs Lookup Tables

| Approach | Use When |
|----------|----------|
| Postgres ENUM | Tiny, stable list that never changes |
| Lookup table + FK | Values evolve, need metadata (labels, sort order) |
| TEXT + CHECK | Small list, occasional changes, no extra metadata |

Recommendation: Use lookup tables for statuses and categories. Add `_lu` suffix to table names.

## Safety Audits

Raw SQL audit blocks DDL outside approved migrations:
- Scans `src/`, `scripts/`, `drizzle/` (excluding `drizzle/migrations/`)
- Fails if `CREATE TABLE`, `ALTER TABLE`, `DROP`, etc. found in code
- Prevents schema drift from non-migration changes

Known scripts with SQL patterns are whitelisted.

## Troubleshooting

Vercel not deploying after merge:
1. Check GitHub Actions tab for failed workflows
2. Failed CI blocks Vercel (appears like webhook issue)
3. Fix failing tests and push again

Migration says "applied successfully" but DB unchanged:
1. Check `drizzle.__drizzle_migrations` table exists
2. Verify hashes in table match `_journal.json`
3. If out of sync, contact team lead (requires manual fix)

RLS tests fail on first-time init:
1. Set repository secret `SKIP_RLS_TESTS=1`
2. Let one deploy complete
3. Delete the secret to re-enable checks





